module.exports={name:"yarn-plugin-nixify",factory:function(e){return(()=>{"use strict";var n={216:(e,n,t)=>{t.r(n),t.d(n,{default:()=>v});var r,i,o,a,s,c,l,p,u,d,h,f,y=t(42),b=t(688),m=t(798),g=t(966);function x(e,n,t,r){t&&Object.defineProperty(e,n,{enumerable:t.enumerable,configurable:t.configurable,writable:t.writable,value:t.initializer?t.initializer.call(r):void 0})}function P(e,n,t,r,i){var o={};return Object.keys(r).forEach((function(e){o[e]=r[e]})),o.enumerable=!!o.enumerable,o.configurable=!!o.configurable,("value"in o||o.initializer)&&(o.writable=!0),o=t.slice().reverse().reduce((function(t,r){return r(e,n,t)||t}),o),i&&void 0!==o.initializer&&(o.value=o.initializer?o.initializer.call(i):void 0,o.initializer=void 0),void 0===o.initializer&&(Object.defineProperty(e,n,o),o=null),o}const v={commands:[(r=y.Command.Path("nixify"),P((i=class extends y.Command{async execute(){const e=await g.Configuration.find(this.context.cwd,this.context.plugins),{project:n}=await g.Project.find(e,this.context.cwd);return(await g.StreamReport.start({configuration:e,stdout:this.context.stdout},async e=>(async(e,n)=>{const{configuration:t,cwd:r}=e,i=t.get("yarnPath"),o=t.get("lockfileFilename");if("pnp"!==t.get("nodeLinker"))return void n.reportError(0,"Only 'pnp' is currently supported for the 'nodeLinker' setting.");const a=b.ppath.relative(r,i);if(a.startsWith("."))return void n.reportError(0,`The Yarn path ${i} is outside the project directory - it cannot be reached by the Nix build`);if(!b.xfs.existsSync(b.ppath.join(r,o))||!b.xfs.existsSync((0,m.getPnpPath)(e).main))return void n.reportError(0,`The project in ${r}/package.json doesn't seem to have been installed - running an install there might help`);const s=new Set(["package.json",o,a]);for(const e of t.sources.values())e.startsWith("<")||s.add(e);const c=b.ppath.join(r,".yarn/plugins");if(b.xfs.existsSync(c))for(const e of b.xfs.readdirSync(c))s.add(b.ppath.join(c,e));const l=new Set;for(const e of s){const t=b.ppath.relative(r,e);if(t.startsWith("..")){n.reportWarning(0,`The path ${e} was ignored, because it cannot be reached by the Nix build`);continue}l.add("regular:"+t);let i=b.ppath.dirname(t);for(;"."!==i;)l.add("directory:"+i),i=b.ppath.dirname(i)}const p=t.get("cacheFolder"),u=(await g.execUtils.execvp("nix-hash",["--type","sha256","--base32",p],{cwd:r,encoding:"utf8",strict:!0})).stdout.trim(),d=e.topLevelWorkspace.manifest.name,h=d?g.structUtils.stringifyIdent(d):"workspace",f="{ lib, bash, nodejs, perl, stdenv, writeText }:\n\nwith lib;\n\nlet\n\n  # Variables provided by the generator.\n  project-name = @@PROJECT_NAME@@;\n  offline-cache-hash = @@OFFLINE_CACHE_HASH@@;\n  yarn-path = @@YARN_PATH@@;\n  yarn-closure-entries = @@YARN_CLOSURE_ENTRIES@@;\n\n  # Defines the shell alias to run Yarn.\n  yarn-alias = ''\n    yarn() {\n      CI=1 \"$NIX_YARN_PATH\" \"$@\"\n    }\n  '';\n\n  # Directory of just the files needed to run Yarn.\n  yarn-closure = cleanSourceWith {\n    src = ./.;\n    filter = let\n      srcStr = toString ./.;\n      srcRel = removePrefix \"${srcStr}/\";\n    in path: type:\n      elem \"${type}:${srcRel path}\" yarn-closure-entries;\n  };\n\n  # Build just the offline cache for the project.\n  offline-cache = stdenv.mkDerivation {\n    name = \"${project-name}-offline-cache\";\n    buildInputs = [ nodejs ];\n    builder = writeText \"builder.sh\" ''\n      source $stdenv/setup\n      cd ${yarn-closure}\n\n      # Yarn may need a writable home directory for the global cache mirror.\n      # TODO: Can't disable the mirror, because it changes cache filenames.\n      export HOME=\"$TEMP\"\n\n      # Setup to environment so we can run Yarn.\n      export NIX_YARN_PATH=\"$PWD/${yarn-path}\"\n      ${yarn-alias}\n\n      # Invoke a plugin internal command to build the cache.\n      yarn nixify build-cache $out\n    '';\n    outputHashMode = \"recursive\";\n    outputHashAlgo = \"sha256\";\n    outputHash = offline-cache-hash;\n  };\n\nin stdenv.mkDerivation {\n  name = project-name;\n  src = ./.;\n\n  # Tell node-gyp to use the provided Node.js headers for native code builds.\n  npm_config_nodedir = nodejs;\n  # Tell node-pre-gyp to never fetch binaries / always build from source.\n  npm_config_build_from_source = \"true\";\n\n  # Make sure the build uses the right Node.js version everywhere.\n  buildInputs = [ nodejs ];\n\n  # Define the Yarn alias in the build environment.\n  postHook = yarn-alias;\n\n  configurePhase = ''\n    runHook preConfigure\n\n    # Move the entire project to the output directory.\n    # TODO: Would rather do this in 'installPhase',\n    # but '.pnp.js' is generated with relative paths.\n    mkdir -p $out/libexec $out/bin\n    mv $PWD \"$out/libexec/$sourceRoot\"\n    cd \"$out/libexec/$sourceRoot\"\n\n    # Store the absolute path to Yarn for the 'yarn' alias.\n    export NIX_YARN_PATH=\"$PWD/${yarn-path}\"\n\n    # Point Yarn to the offline cache built separately.\n    yarn config set cacheFolder '${offline-cache}'\n\n    # Run normal Yarn install to complete dependency installation.\n    yarn install --immutable --immutable-cache\n\n    runHook postConfigure\n  '';\n\n  buildPhase = ''\n    runHook preBuild\n    runHook postBuild\n  '';\n\n  installPhase = ''\n    runHook preInstall\n\n    # Invoke a plugin internal command to setup binaries.\n    yarn nixify install-bin $out/bin\n\n    runHook postInstall\n  '';\n\n  passthru = {\n    inherit yarn-closure offline-cache;\n  };\n}\n".replace("@@PROJECT_NAME@@",JSON.stringify(h)).replace("@@OFFLINE_CACHE_HASH@@",JSON.stringify(u)).replace("@@YARN_PATH@@",JSON.stringify(a)).replace("@@YARN_CLOSURE_ENTRIES@@","[ "+[...l].map(e=>JSON.stringify(e)).join(" ")+" ]"),y=b.ppath.join(r,"yarn-project.nix");b.xfs.writeFileSync(y,f),n.reportInfo(0,"Wrote: "+y);const x=b.ppath.join(r,"default.nix");b.xfs.existsSync(x)||(b.xfs.writeFileSync(x,"{ pkgs ? import <nixpkgs> {} }:\n\npkgs.callPackage ./yarn-project.nix {}\n"),n.reportInfo(0,"Wrote: "+x))})(n,e))).exitCode()}}).prototype,"execute",[r],Object.getOwnPropertyDescriptor(i.prototype,"execute"),i.prototype),i),(o=y.Command.String(),a=y.Command.Path("nixify","build-cache"),l=class extends y.Command{constructor(...e){super(...e),x(this,"out",c,this)}async execute(){const e=await g.Configuration.find(this.context.cwd,this.context.plugins);e.use("<nixify>",{cacheFolder:this.out},e.projectCwd,{overwrite:!0});const{project:n}=await g.Project.find(e,this.context.cwd),t=await g.Cache.find(e);return(await g.StreamReport.start({configuration:e,stdout:this.context.stdout},async e=>{await e.startTimerPromise("Resolution step",()=>n.resolveEverything({report:e,lockfileOnly:!0})),await e.startTimerPromise("Fetch step",()=>n.fetchEverything({cache:t,report:e}))})).exitCode()}},c=P((s=l).prototype,"out",[o],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return""}}),P(s.prototype,"execute",[a],Object.getOwnPropertyDescriptor(s.prototype,"execute"),s.prototype),s),(p=y.Command.String(),u=y.Command.Path("nixify","install-bin"),f=class extends y.Command{constructor(...e){super(...e),x(this,"binDir",h,this)}async execute(){const e=await g.Configuration.find(this.context.cwd,this.context.plugins),{project:n,workspace:t}=await g.Project.find(e,this.context.cwd);if(t){const e=b.npath.toPortablePath(this.binDir),r=(0,m.getPnpPath)(n).main;for(const[i,o]of t.manifest.bin){const t=b.ppath.join(e,i),a=b.ppath.join(n.cwd,b.npath.toPortablePath(o)),s="#!/bin/sh\nexec node -r '@@PNP_PATH@@' '@@SCRIPT_PATH@@' \"$@\"\n".replace("@@PNP_PATH@@",r).replace("@@SCRIPT_PATH@@",a);b.xfs.writeFileSync(t,s),b.xfs.chmodSync(t,493)}}}},h=P((d=f).prototype,"binDir",[p],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return""}}),P(d.prototype,"execute",[u],Object.getOwnPropertyDescriptor(d.prototype,"execute"),d.prototype),d)]}},966:n=>{n.exports=e("@yarnpkg/core")},688:n=>{n.exports=e("@yarnpkg/fslib")},798:n=>{n.exports=e("@yarnpkg/plugin-pnp")},42:n=>{n.exports=e("clipanion")}},t={};function r(e){if(t[e])return t[e].exports;var i=t[e]={exports:{}};return n[e](i,i.exports,r),i.exports}return r.d=(e,n)=>{for(var t in n)r.o(n,t)&&!r.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},r.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r(216)})()}};