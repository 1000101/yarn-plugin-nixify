module.exports={name:"yarn-plugin-nixify",factory:function(e){return(()=>{"use strict";var n={609:(e,n,t)=>{t.r(n),t.d(n,{default:()=>P});var i,r,o,a,s,c,l,p,u,h,d=t(42),f=t(688),b=t(798),y=t(966);function m(e,n,t,i){t&&Object.defineProperty(e,n,{enumerable:t.enumerable,configurable:t.configurable,writable:t.writable,value:t.initializer?t.initializer.call(i):void 0})}function g(e,n,t,i,r){var o={};return Object.keys(i).forEach((function(e){o[e]=i[e]})),o.enumerable=!!o.enumerable,o.configurable=!!o.configurable,("value"in o||o.initializer)&&(o.writable=!0),o=t.slice().reverse().reduce((function(t,i){return i(e,n,t)||t}),o),r&&void 0!==o.initializer&&(o.value=o.initializer?o.initializer.call(r):void 0,o.initializer=void 0),void 0===o.initializer&&(Object.defineProperty(e,n,o),o=null),o}const x=["pnp","node-modules"],P={commands:[(i=d.Command.String(),r=d.Command.Path("nixify","fetch-one"),s=class extends d.Command{constructor(...e){super(...e),m(this,"locatorHash",a,this)}async execute(){const e=await y.Configuration.find(this.context.cwd,this.context.plugins),{project:n}=await y.Project.find(e,this.context.cwd),t=await y.Cache.find(e),i=e.makeFetcher();return(await y.StreamReport.start({configuration:e,stdout:this.context.stdout},async e=>{const r=n.originalPackages.get(this.locatorHash);r?await i.fetch(r,{checksums:n.storedChecksums,project:n,cache:t,fetcher:i,report:e}):e.reportError(0,"Invalid locator hash")})).exitCode()}},a=g((o=s).prototype,"locatorHash",[i],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return""}}),g(o.prototype,"execute",[r],Object.getOwnPropertyDescriptor(o.prototype,"execute"),o.prototype),o),(c=d.Command.String(),l=d.Command.Path("nixify","install-bin"),h=class extends d.Command{constructor(...e){super(...e),m(this,"binDir",u,this)}async execute(){const e=await y.Configuration.find(this.context.cwd,this.context.plugins),{project:n,workspace:t}=await y.Project.find(e,this.context.cwd);await y.StreamReport.start({configuration:e,stdout:this.context.stdout},async i=>{if(!t||0===t.manifest.bin.size)return;let r=e.get("nodeLinker");x.includes(r)||(r="node-modules",i.reportWarning(0,`The nodeLinker ${r} is not supported - executables may have trouble finding dependencies`));const o=f.npath.toPortablePath(this.binDir),a=(0,b.getPnpPath)(n).main;for(const[e,i]of t.manifest.bin){const t=f.ppath.join(o,e),s=f.ppath.join(n.cwd,f.npath.toPortablePath(i));let c;switch(r){case"pnp":c="#!/bin/sh\nexec node -r '@@PNP_PATH@@' '@@SCRIPT_PATH@@' \"$@\"\n".replace("@@PNP_PATH@@",a).replace("@@SCRIPT_PATH@@",s);break;case"node-modules":c="#!/bin/sh\nexec node '@@SCRIPT_PATH@@' \"$@\"\n".replace("@@SCRIPT_PATH@@",s);break;default:throw Error("Invalid nodeLinker "+r)}f.xfs.writeFileSync(t,c),f.xfs.chmodSync(t,493)}})}},u=g((p=h).prototype,"binDir",[c],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return""}}),g(p.prototype,"execute",[l],Object.getOwnPropertyDescriptor(p.prototype,"execute"),p.prototype),p)],hooks:{afterAllInstalled:async(e,n)=>{!1!==n.persistProject&&await(async(e,n,t)=>{const{configuration:i,cwd:r}=e,o=i.get("yarnPath"),a=i.get("cacheFolder");let s=f.ppath.relative(r,o);s.startsWith("../")&&(s=o,t.reportWarning(0,`The Yarn path ${o} is outside the project - it may not be reachable by the Nix build`));let c=f.ppath.relative(r,a);c.startsWith("../")&&(c=a,t.reportWarning(0,`The cache folder ${a} is outside the project - it may not be reachable by the Nix build`));for(const e of i.sources.values())e.startsWith("<")||f.ppath.relative(r,e).startsWith("../")&&t.reportWarning(0,`The config file ${e} is outside the project - it may not be reachable by the Nix build`);let l=[];const p=new Set(f.xfs.readdirSync(n.cwd));for(const t of e.storedPackages.values()){const i=e.storedChecksums.get(t.locatorHash);if(!i)continue;const r=n.getLocatorPath(t,i);if(!r)continue;const o=f.ppath.basename(r);if(!p.has(o))continue;const a=i.split("/").pop();l.push([`filename = ${JSON.stringify(o)};`,`sha512 = ${JSON.stringify(a)};`,`locator-hash = ${JSON.stringify(t.locatorHash)};`])}const u=e.topLevelWorkspace.manifest.name,h=u?y.structUtils.stringifyIdent(u):"workspace",d="# This file is generated by running \"yarn install\" inside your project.\n# Manual changes might be lost - proceed with caution!\n\n{ lib, coreutils, nodejs, stdenv, src ? ./. }:\n\nwith lib;\n\nlet\n\n  # Variables provided by the generator.\n  project-name = @@PROJECT_NAME@@;\n  yarn-path = @@YARN_PATH@@;\n  cache-folder = @@CACHE_FOLDER@@;\n  cache-entries = @@CACHE_ENTRIES@@;\n\n  # Defines the shell alias to run Yarn.\n  yarn-alias = ''\n    yarn() {\n      CI=1 node \"$NIX_YARN_PATH\" \"$@\"\n    }\n  '';\n\n  # Fetch a single dependency.\n  fetch = { filename, sha512, locator-hash }: stdenv.mkDerivation {\n    name = replaceStrings [ \"@\" ] [ \"-\" ] filename;\n    buildInputs = [ nodejs ];\n    builder = builtins.toFile \"builder.sh\" ''\n      source $stdenv/setup\n\n      # Yarn may need a writable home directory for the global cache mirror.\n      # TODO: Can't disable the mirror, because it changes cache filenames.\n      export HOME=\"$PWD\"\n\n      # Fetch into the build directory.\n      export yarn_cache_folder=\"$PWD\"\n\n      # Setup to environment so we can run Yarn.\n      pushd '${src}' > /dev/null\n\n      export NIX_YARN_PATH=\"$(readlink -f '${yarn-path}')\"\n      ${yarn-alias}\n\n      # Invoke a plugin internal command to build the cache.\n      yarn nixify fetch-one '${locator-hash}'\n\n      popd > /dev/null\n\n      # The cache file that was just fetched is our output.\n      mv '${filename}' $out\n    '';\n    outputHashMode = \"flat\";\n    outputHashAlgo = \"sha512\";\n    outputHash = sha512;\n  };\n\n  # Shell snippet to collect all project dependencies.\n  collect-cache = concatMapStrings (args: ''\n    cp ${fetch args} './${args.filename}'\n  '') cache-entries;\n\nin stdenv.mkDerivation {\n  name = project-name;\n  inherit src;\n\n  # Tell node-gyp to use the provided Node.js headers for native code builds.\n  npm_config_nodedir = nodejs;\n  # Tell node-pre-gyp to never fetch binaries / always build from source.\n  npm_config_build_from_source = \"true\";\n\n  # Make sure the build uses the right Node.js version everywhere.\n  buildInputs = [ coreutils nodejs ];\n\n  # Define the Yarn alias in the build environment.\n  postHook = yarn-alias;\n\n  configurePhase = ''\n    runHook preConfigure\n\n    # Copy over the Yarn cache.\n    # TODO: Can we do without the copy somehow? Links don't work.\n    rm -fr '${cache-folder}'\n    mkdir -p '${cache-folder}'\n    pushd '${cache-folder}' > /dev/null\n    ${collect-cache}\n    popd > /dev/null\n\n    # Store the absolute path to Yarn for the 'yarn' alias.\n    export NIX_YARN_PATH=\"$(readlink -f '${yarn-path}')\"\n\n    # Run normal Yarn install to complete dependency installation.\n    yarn install --immutable --immutable-cache\n\n    runHook postConfigure\n  '';\n\n  buildPhase = ''\n    runHook preBuild\n    runHook postBuild\n  '';\n\n  installPhase = ''\n    runHook preInstall\n\n    mkdir -p $out/libexec $out/bin\n\n    # Move the entire project to the output directory.\n    mv $PWD \"$out/libexec/$sourceRoot\"\n    cd \"$out/libexec/$sourceRoot\"\n\n    # Update the path to Yarn.\n    export NIX_YARN_PATH=\"$(readlink -f '${yarn-path}')\"\n\n    # Invoke a plugin internal command to setup binaries.\n    yarn nixify install-bin $out/bin\n\n    runHook postInstall\n  '';\n\n  passthru = {\n    inherit offline-cache;\n  };\n}\n".replace("@@PROJECT_NAME@@",JSON.stringify(h)).replace("@@YARN_PATH@@",JSON.stringify(s)).replace("@@CACHE_FOLDER@@",JSON.stringify(c)).replace("@@CACHE_ENTRIES@@","[\n"+[...l].map(e=>`    { ${e.join(" ")} }\n`).join("")+"  ]"),b=f.ppath.join(r,"yarn-project.nix");f.xfs.writeFileSync(b,d);const m=f.ppath.join(r,"default.nix");f.xfs.existsSync(m)||(f.xfs.writeFileSync(m,"# This is a minimal `default.nix` by yarn-plugin-nixify. You can customize it\n# as needed, it will not be overwritten by the plugin.\n\n{ pkgs ? import <nixpkgs> {} }:\n\npkgs.callPackage ./yarn-project.nix {}\n"),t.reportInfo(0,"A minimal default.nix was created. You may want to customize it."))})(e,n.cache,n.report)}}}},966:n=>{n.exports=e("@yarnpkg/core")},688:n=>{n.exports=e("@yarnpkg/fslib")},798:n=>{n.exports=e("@yarnpkg/plugin-pnp")},42:n=>{n.exports=e("clipanion")}},t={};function i(e){if(t[e])return t[e].exports;var r=t[e]={exports:{}};return n[e](r,r.exports,i),r.exports}return i.d=(e,n)=>{for(var t in n)i.o(n,t)&&!i.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},i.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),i.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i(609)})()}};