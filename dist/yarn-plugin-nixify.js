module.exports={name:"yarn-plugin-nixify",factory:function(e){return(()=>{"use strict";var n={216:(e,n,t)=>{t.r(n),t.d(n,{default:()=>x});var r,i,o,a,s,c,l,p,u,h,d=t(42),f=t(688),y=t(798),m=t(966);function b(e,n,t,r){t&&Object.defineProperty(e,n,{enumerable:t.enumerable,configurable:t.configurable,writable:t.writable,value:t.initializer?t.initializer.call(r):void 0})}function g(e,n,t,r,i){var o={};return Object.keys(r).forEach((function(e){o[e]=r[e]})),o.enumerable=!!o.enumerable,o.configurable=!!o.configurable,("value"in o||o.initializer)&&(o.writable=!0),o=t.slice().reverse().reduce((function(t,r){return r(e,n,t)||t}),o),i&&void 0!==o.initializer&&(o.value=o.initializer?o.initializer.call(i):void 0,o.initializer=void 0),void 0===o.initializer&&(Object.defineProperty(e,n,o),o=null),o}const x={commands:[(r=d.Command.String(),i=d.Command.Path("nixify","fetch-one"),s=class extends d.Command{constructor(...e){super(...e),b(this,"locatorHash",a,this)}async execute(){const e=await m.Configuration.find(this.context.cwd,this.context.plugins),{project:n}=await m.Project.find(e,this.context.cwd),t=await m.Cache.find(e),r=e.makeFetcher();return(await m.StreamReport.start({configuration:e,stdout:this.context.stdout},async e=>{const i=n.originalPackages.get(this.locatorHash);i?await r.fetch(i,{checksums:n.storedChecksums,project:n,cache:t,fetcher:r,report:e}):e.reportError(0,"Invalid locator hash")})).exitCode()}},a=g((o=s).prototype,"locatorHash",[r],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return""}}),g(o.prototype,"execute",[i],Object.getOwnPropertyDescriptor(o.prototype,"execute"),o.prototype),o),(c=d.Command.String(),l=d.Command.Path("nixify","install-bin"),h=class extends d.Command{constructor(...e){super(...e),b(this,"binDir",u,this)}async execute(){const e=await m.Configuration.find(this.context.cwd,this.context.plugins),{project:n,workspace:t}=await m.Project.find(e,this.context.cwd);if(t){const e=f.npath.toPortablePath(this.binDir),r=(0,y.getPnpPath)(n).main;for(const[i,o]of t.manifest.bin){const t=f.ppath.join(e,i),a=f.ppath.join(n.cwd,f.npath.toPortablePath(o)),s="#!/bin/sh\nexec node -r '@@PNP_PATH@@' '@@SCRIPT_PATH@@' \"$@\"\n".replace("@@PNP_PATH@@",r).replace("@@SCRIPT_PATH@@",a);f.xfs.writeFileSync(t,s),f.xfs.chmodSync(t,493)}}}},u=g((p=h).prototype,"binDir",[c],{configurable:!0,enumerable:!0,writable:!0,initializer:function(){return""}}),g(p.prototype,"execute",[l],Object.getOwnPropertyDescriptor(p.prototype,"execute"),p.prototype),p)],hooks:{afterAllInstalled:async(e,n)=>{!1!==n.persistProject&&await(async(e,n,t)=>{const{configuration:r,cwd:i}=e,o=r.get("yarnPath"),a=r.get("cacheFolder"),s=r.get("lockfileFilename");if("pnp"!==r.get("nodeLinker"))return void t.reportWarning(0,"Currently, yarn-plugin-nixify only supports 'pnp' for the 'nodeLinker' setting.");let c=f.ppath.relative(i,o);c.startsWith("../")&&(c=o,t.reportWarning(0,`The Yarn path ${o} is outside the project - it may not be reachable by the Nix build`));let l=f.ppath.relative(i,a);l.startsWith("../")&&(l=a,t.reportWarning(0,`The cache folder ${a} is outside the project - it may not be reachable by the Nix build`));const p=new Set(["package.json",s,c]);for(const e of r.sources.values())e.startsWith("<")||p.add(e);const u=f.ppath.join(i,".yarn/plugins");if(f.xfs.existsSync(u))for(const e of f.xfs.readdirSync(u))p.add(f.ppath.join(u,e));const h=new Set;for(const e of p){const n=f.ppath.relative(i,e);if(n.startsWith("../")){e!==c&&t.reportWarning(0,`The path ${e} is outside the project and was ignored - it may not be reachable in the Nix build`);continue}h.add("regular:"+n);let r=f.ppath.dirname(n);for(;"."!==r;)h.add("directory:"+r),r=f.ppath.dirname(r)}let d=[];const y=new Set(f.xfs.readdirSync(n.cwd));for(const t of e.storedPackages.values()){const r=e.storedChecksums.get(t.locatorHash);if(!r)continue;const i=n.getLocatorPath(t,r);if(!i)continue;const o=f.ppath.basename(i);if(!y.has(o))continue;const a=r.split("/").pop();d.push([`filename = ${JSON.stringify(o)};`,`sha512 = ${JSON.stringify(a)};`,`locator-hash = ${JSON.stringify(t.locatorHash)};`])}const b=e.topLevelWorkspace.manifest.name,g=b?m.structUtils.stringifyIdent(b):"workspace",x="# This file is generated by running \"yarn install\" inside your project.\n# Manual changes might be lost - proceed with caution!\n\n{ lib, bash, coreutils, nodejs, perl, stdenv, writeText }:\n\nwith lib;\n\nlet\n\n  # Variables provided by the generator.\n  project-name = @@PROJECT_NAME@@;\n  cache-folder = @@CACHE_FOLDER@@;\n  cache-entries = @@CACHE_ENTRIES@@;\n  yarn-path = @@YARN_PATH@@;\n  yarn-closure-entries = @@YARN_CLOSURE_ENTRIES@@;\n\n  # Defines the shell alias to run Yarn.\n  yarn-alias = ''\n    yarn() {\n      CI=1 node \"$NIX_YARN_PATH\" \"$@\"\n    }\n  '';\n\n  # Directory of just the files needed to run Yarn.\n  yarn-closure = cleanSourceWith {\n    src = ./.;\n    filter = let\n      srcStr = toString ./.;\n      srcRel = removePrefix \"${srcStr}/\";\n    in path: type:\n      elem \"${type}:${srcRel path}\" yarn-closure-entries;\n  };\n\n  # Fetch a single dependency.\n  fetch = { filename, sha512, locator-hash }: stdenv.mkDerivation {\n    name = replaceStrings [ \"@\" ] [ \"-\" ] filename;\n    buildInputs = [ nodejs ];\n    builder = builtins.toFile \"builder.sh\" ''\n      source $stdenv/setup\n\n      # Yarn may need a writable home directory for the global cache mirror.\n      # TODO: Can't disable the mirror, because it changes cache filenames.\n      export HOME=\"$PWD\"\n\n      # Fetch into the build directory.\n      export yarn_cache_folder=\"$PWD\"\n\n      # Setup to environment so we can run Yarn.\n      pushd '${yarn-closure}' > /dev/null\n\n      export NIX_YARN_PATH=\"$(readlink -f '${yarn-path}')\"\n      ${yarn-alias}\n\n      # Invoke a plugin internal command to build the cache.\n      yarn nixify fetch-one '${locator-hash}'\n\n      popd > /dev/null\n\n      # The cache file that was just fetched is our output.\n      mv '${filename}' $out\n    '';\n    outputHashMode = \"flat\";\n    outputHashAlgo = \"sha512\";\n    outputHash = sha512;\n  };\n\n  # Shell snippet to collect all project dependencies.\n  collect-cache = concatMapStrings (args: ''\n    cp ${fetch args} './${args.filename}'\n  '') cache-entries;\n\nin stdenv.mkDerivation {\n  name = project-name;\n  src = ./.;\n\n  # Tell node-gyp to use the provided Node.js headers for native code builds.\n  npm_config_nodedir = nodejs;\n  # Tell node-pre-gyp to never fetch binaries / always build from source.\n  npm_config_build_from_source = \"true\";\n\n  # Make sure the build uses the right Node.js version everywhere.\n  buildInputs = [ coreutils nodejs ];\n\n  # Define the Yarn alias in the build environment.\n  postHook = yarn-alias;\n\n  configurePhase = ''\n    runHook preConfigure\n\n    # Copy over the Yarn cache.\n    # TODO: Can we do without the copy somehow? Links don't work.\n    rm -fr '${cache-folder}'\n    mkdir -p '${cache-folder}'\n    pushd '${cache-folder}' > /dev/null\n    ${collect-cache}\n    popd > /dev/null\n\n    # Store the absolute path to Yarn for the 'yarn' alias.\n    export NIX_YARN_PATH=\"$(readlink -f '${yarn-path}')\"\n\n    # Run normal Yarn install to complete dependency installation.\n    yarn install --immutable --immutable-cache\n\n    runHook postConfigure\n  '';\n\n  buildPhase = ''\n    runHook preBuild\n    runHook postBuild\n  '';\n\n  installPhase = ''\n    runHook preInstall\n\n    mkdir -p $out/libexec $out/bin\n\n    # Move the entire project to the output directory.\n    mv $PWD \"$out/libexec/$sourceRoot\"\n    cd \"$out/libexec/$sourceRoot\"\n\n    # Update the path to Yarn.\n    export NIX_YARN_PATH=\"$(readlink -f '${yarn-path}')\"\n\n    # Invoke a plugin internal command to setup binaries.\n    yarn nixify install-bin $out/bin\n\n    runHook postInstall\n  '';\n\n  passthru = {\n    inherit yarn-closure offline-cache;\n  };\n}\n".replace("@@PROJECT_NAME@@",JSON.stringify(g)).replace("@@CACHE_FOLDER@@",JSON.stringify(l)).replace("@@CACHE_ENTRIES@@","[\n"+[...d].map(e=>`    { ${e.join(" ")} }\n`).join("")+"  ]").replace("@@YARN_PATH@@",JSON.stringify(c)).replace("@@YARN_CLOSURE_ENTRIES@@","[\n"+[...h].map(e=>`    ${JSON.stringify(e)}\n`).join("")+"  ]"),v=f.ppath.join(i,"yarn-project.nix");f.xfs.writeFileSync(v,x);const P=f.ppath.join(i,"default.nix");f.xfs.existsSync(P)||(f.xfs.writeFileSync(P,"# This is a minimal `default.nix` by yarn-plugin-nixify. You can customize it\n# as needed, it will not be overwritten by the plugin.\n\n{ pkgs ? import <nixpkgs> {} }:\n\npkgs.callPackage ./yarn-project.nix {}\n"),t.reportInfo(0,"A minimal default.nix was created. You may want to customize it."))})(e,n.cache,n.report)}}}},966:n=>{n.exports=e("@yarnpkg/core")},688:n=>{n.exports=e("@yarnpkg/fslib")},798:n=>{n.exports=e("@yarnpkg/plugin-pnp")},42:n=>{n.exports=e("clipanion")}},t={};function r(e){if(t[e])return t[e].exports;var i=t[e]={exports:{}};return n[e](i,i.exports,r),i.exports}return r.d=(e,n)=>{for(var t in n)r.o(n,t)&&!r.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},r.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r(216)})()}};